<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.RoleMapper">

    <!-- 定义 resultMap，用于关联角色和权限 -->
    <resultMap id="RoleWithauthorityMap" type="com.example.model.Role">
        <id property="id" column="role_id"/>
        <result property="role" column="role"/>
        <result property="description" column="description"/>
        
        <!-- 使用 collection 元素关联权限列表 -->
        <collection property="authority" ofType="com.example.model.Authority">
            <id property="id" column="authority_id"/>
            <result property="name" column="authority_name"/>
            <result property="description" column="authority_description"/>
        </collection>
    </resultMap>

    <!-- 查询所有未删除的角色及其权限信息 -->
    <select id="selectAllrole" resultMap="RoleWithauthorityMap">
        SELECT
            r.id AS role_id, r.role, r.description,
            a.id AS authority_id, a.name AS authority_name, a.description AS authority_description
        FROM
            role r
        LEFT JOIN role_authority ra ON r.id = ra.role_id
        LEFT JOIN authority a ON ra.authority_id = a.id
        WHERE
            r.delete_flag = '0'
        </select>


    <!-- 查询角色信息及其权限通过角色 ID，忽略已删除的角色 -->
    <select id="selectRoleById" parameterType="int" resultMap="RoleWithauthorityMap">
        SELECT 
            r.id AS role_id, r.role, r.description,
            a.id AS authority_id, a.name AS authority_name, a.description AS authority_description
        FROM 
            role r
        LEFT JOIN 
            role_authority ra ON r.id = ra.role_id
        LEFT JOIN 
            authority a ON ra.authority_id = a.id
        WHERE 
            r.id = #{id} AND r.delete_flag = '0'
    </select>

    <!-- 查询所有未删除的角色及其权限信息 -->
    <select id="selectAllrole" resultMap="RoleWithauthorityMap">
        SELECT 
            r.id AS role_id, r.role, r.description,
            a.id AS authority_id, a.name AS authority_name, a.description AS authority_description
        FROM 
            role r
        LEFT JOIN 
            role_authority ra ON r.id = ra.role_id
        LEFT JOIN 
            authority a ON ra.authority_id = a.id
        WHERE 
            r.delete_flag = '0'
    </select>

    <!-- 插入角色 -->
    <insert id="insertRole" parameterType="com.example.model.Role">
        INSERT INTO role (id, role, description, delete_flag) VALUES (#{id}, #{role}, #{description}, '0')
    </insert>

    <!-- 更新角色 -->
    <update id="updateRole" parameterType="com.example.model.Role">
        UPDATE role SET role = #{role}, description = #{description} WHERE id = #{id}
    </update>

    <!-- 逻辑删除角色，将 delete_flag 设置为 '1' -->
    <update id="deleteRole" parameterType="int">
        UPDATE role SET delete_flag = '1' WHERE id = #{id}
    </update>

    <!-- assignAuthoritiesToRole(String roleId, List<String> authorityIds) 方法 -->
    <insert id="assignAuthoritiesToRole" parameterType="map">
        INSERT INTO role_authority (role_id, authority_id)
        VALUES
        <foreach collection="authorityIds" item="authorityId" separator=",">
        (#{roleId}, #{authorityId})
        </foreach>
        ON DUPLICATE KEY UPDATE role_id = VALUES(role_id), authority_id = VALUES(authority_id)
        <!-- 使用 ON DUPLICATE KEY UPDATE 来处理重复插入的情况 -->
        <!-- 如果主键（role_id 和 authority_id）已经存在，则更新对应的值 -->
        <!-- 如果主键不存在，则插入新的记录 -->
        <!-- 注意：ON DUPLICATE KEY UPDATE 是 MySQL 特有的语法，其他数据库可能需要使用其他方法来处理重复插入的情况 -->
    </insert>
</mapper>
